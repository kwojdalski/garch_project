---
title: "GARCH Model Implementation"
author: "Based on Engle (2001)"
format: 
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    theme: cosmo
    highlight-style: github
execute:
  echo: true
  warning: false
---

# Introduction

This Quarto document implements a GARCH(1,1) model based on the paper "GARCH 101: The Use of ARCH/GARCH Models in Applied Econometrics" by Robert F. Engle. The implementation includes data fetching, model estimation, and volatility forecasting.

## Setup

First, let's load the required libraries:

```{python}
#| label: setup
import numpy as np
import pandas as pd
import yfinance as yf
from arch import arch_model
from datetime import datetime, timedelta
from plotnine import *
from plotnine.data import mpg
from scipy import stats

```

# Data Preparation

## Fetching Stock Data

We'll fetch S&P 500 data from Yahoo Finance:

```{python}
#| label: fetch-data
# Parameters
symbol = "^GSPC"  # S&P 500 index
end_date = datetime.now()
start_date = end_date - timedelta(days=365*2)  # 2 years of data

# Fetch data
print("Fetching data...")
stock = yf.Ticker(symbol)
df = stock.history(start=start_date, end=end_date)
prices = df['Close']

# Display the first few rows
prices.head()
```

## Calculating Returns

Next, we calculate the log returns:

```{python}
#| label: calculate-returns
# Calculate log returns
returns = np.log(prices / prices.shift(1)).dropna()

# Display the first few rows
returns.head()
```

## Visualizing Price and Returns

Let's visualize both the price series and returns using plotnine:

```{python}
#| label: visualize-data
#| fig-cap: "S&P 500 Price and Log Returns"

# Create dataframes for plotting
price_df = pd.DataFrame({
    'Date': prices.index,
    'Price': prices.values
})

returns_df = pd.DataFrame({
    'Date': returns.index,
    'Return': returns.values
})

# Create price plot
price_plot = (ggplot(price_df, aes(x='Date', y='Price')) +
              geom_line(color='#3366CC') +
              labs(title='S&P 500 Price',
                   x='Date',
                   y='Price') +
              theme_minimal() +
              theme(plot_title=element_text(size=14, face='bold'),
                    axis_title=element_text(size=12),
                    axis_text=element_text(size=10)))

# Create returns plot
returns_plot = (ggplot(returns_df, aes(x='Date', y='Return')) +
                geom_line(color='#FF9900') +
                labs(title='Log Returns',
                     x='Date',
                     y='Log Return') +
                theme_minimal() +
                theme(plot_title=element_text(size=14, face='bold'),
                      axis_title=element_text(size=12),
                      axis_text=element_text(size=10)))

# Display plots
print(price_plot)
print(returns_plot)
```

# GARCH Model Estimation

## Fitting the GARCH(1,1) Model

Now we'll fit a GARCH(1,1) model to the returns data:

```{python}
#| label: fit-garch
# Fit GARCH(1,1) model
print("Fitting GARCH(1,1) model...")
model = arch_model(returns, p=1, q=1, vol='Garch', dist='normal')
results = model.fit(disp='off')

# Display model summary
print("\nModel Summary:")
print(results.summary())
```

## Model Parameters

The GARCH(1,1) model is specified as:

$$\sigma_t^2 = \omega + \alpha_1 \varepsilon_{t-1}^2 + \beta_1 \sigma_{t-1}^2$$

where:
- $\sigma_t^2$ is the conditional variance
- $\omega$ is the constant term
- $\alpha_1$ is the ARCH effect
- $\beta_1$ is the GARCH effect
- $\varepsilon_{t-1}^2$ is the squared lagged returns
- $\sigma_{t-1}^2$ is the lagged conditional variance

Let's extract and display the model parameters:

```{python}
#| label: model-parameters
# Extract parameters
params = results.params
print("Model Parameters:")
for param, value in params.items():
    print(f"{param}: {value:.6f}")
```

# Volatility Analysis

## Conditional Volatility

Let's plot the conditional volatility using plotnine:

```{python}
#| label: plot-volatility
#| fig-cap: "Conditional Volatility"

# Create dataframe for volatility
volatility_df = pd.DataFrame({
    'Date': returns.index,
    'Volatility': np.sqrt(results.conditional_volatility)
})

# Create volatility plot
volatility_plot = (ggplot(volatility_df, aes(x='Date', y='Volatility')) +
                   geom_line(color='#3366CC') +
                   labs(title='Conditional Volatility',
                        x='Date',
                        y='Volatility') +
                   theme_minimal() +
                   theme(plot_title=element_text(size=14, face='bold'),
                         axis_title=element_text(size=12),
                         axis_text=element_text(size=10)))

# Display plot
print(volatility_plot)
```

## Model Diagnostics

Let's examine the model residuals using plotnine:

```{python}
#| label: model-diagnostics
#| fig-cap: "Standardized Residuals and Q-Q Plot"

# Get standardized residuals
std_resid = results.resid / np.sqrt(results.conditional_volatility)

# Create dataframe for residuals
resid_df = pd.DataFrame({
    'Date': std_resid.index,
    'Residual': std_resid.values
})

# Create residuals plot
resid_plot = (ggplot(resid_df, aes(x='Date', y='Residual')) +
              geom_line(color='#FF9900') +
              labs(title='Standardized Residuals',
                   x='Date',
                   y='Standardized Residual') +
              theme_minimal() +
              theme(plot_title=element_text(size=14, face='bold'),
                    axis_title=element_text(size=12),
                    axis_text=element_text(size=10)))

# For Q-Q plot, we need to use matplotlib as plotnine doesn't have a direct Q-Q plot
# Create a figure with two subplots
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

# Plot residuals using plotnine
print(resid_plot)

# Q-Q plot using matplotlib
stats.probplot(std_resid, dist="norm", plot=ax2)
ax2.set_title('Q-Q Plot of Standardized Residuals')
plt.tight_layout()
plt.show()
```

# Volatility Forecasting

## Generating Forecasts

Let's generate volatility forecasts:

```{python}
#| label: forecast
# Generate forecasts
print("Generating volatility forecast...")
forecast = results.forecast(horizon=5)
print("\nVolatility Forecast:")
print(forecast.variance.iloc[-1])
```

## Visualizing Forecasts

Let's visualize the forecast using plotnine:

```{python}
#| label: plot-forecast
#| fig-cap: "Volatility Forecast"

# Create dataframes for historical and forecast data
historical_df = pd.DataFrame({
    'Date': returns.index[-100:],
    'Volatility': np.sqrt(results.conditional_volatility[-100:]),
    'Type': 'Historical'
})

forecast_dates = pd.date_range(returns.index[-1], periods=6)[1:]
forecast_df = pd.DataFrame({
    'Date': forecast_dates,
    'Volatility': np.sqrt(forecast.variance.iloc[-1]),
    'Type': 'Forecast'
})

# Combine dataframes
combined_df = pd.concat([historical_df, forecast_df])

# Create forecast plot
forecast_plot = (ggplot(combined_df, aes(x='Date', y='Volatility', color='Type')) +
                 geom_line() +
                 labs(title='Volatility Forecast',
                      x='Date',
                      y='Volatility') +
                 scale_color_manual(values=['#3366CC', '#FF9900']) +
                 theme_minimal() +
                 theme(plot_title=element_text(size=14, face='bold'),
                       axis_title=element_text(size=12),
                       axis_text=element_text(size=10),
                       legend_title=element_blank()))

# Display plot
print(forecast_plot)
```

# Conclusion

This implementation demonstrates the key components of GARCH modeling:

1. Data preparation and log returns calculation
2. GARCH(1,1) model estimation
3. Volatility analysis and visualization
4. Model diagnostics
5. Volatility forecasting

The GARCH model provides a powerful framework for modeling and forecasting financial volatility, which is essential for risk management and asset pricing. 
