---
title: GARCH Model Implementation
author: Based on Engle (2001)
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    theme: cosmo
    highlight-style: github
execute:
  echo: true
  warning: false
jupyter:
  jupytext:
    text_representation:
      extension: .qmd
      format_name: quarto
      format_version: '1.0'
      jupytext_version: 1.17.0
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
    path: /usr/local/share/jupyter/kernels/python3
---

```{python}
#| label: setup
import numpy as np
import pandas as pd
import yfinance as yf
from datetime import datetime, timedelta
from plotnine import *
from plotnine.data import mpg
from scipy import stats
import sys
import os
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Add the src directory to the Python path
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'src'))

# Import our GARCH implementation functions
from utils import (
    fetch_stock_data,
    calculate_returns,
    fit_garch,
    plot_volatility
)
```

# Data Preparation

## Fetching Stock Data

We'll fetch S&P 500 data using our implementation function:

```{python}
#| label: fetch-data
# Parameters
symbol = "^GSPC"  # S&P 500 index
end_date = datetime.now()
start_date = end_date - timedelta(days=365*2)  # 2 years of data

# Fetch data using our implementation
logger.info("Fetching data...")
prices = fetch_stock_data(symbol, start_date, end_date)

# Display the first few rows
prices.head()
```

## Calculating Returns

Next, we calculate the log returns using our implementation function:

```{python}
#| label: calculate-returns
# Calculate log returns using our implementation
returns = calculate_returns(prices)

# Display the first few rows
returns.head()
```

## Visualizing Price and Returns

Let's visualize both the price series and returns using plotnine:

```{python}
#| label: visualize-data
#| fig-cap: S&P 500 Price and Log Returns

# Create dataframes for plotting
price_df = pd.DataFrame({
    'Date': prices.index,
    'Price': prices.values
})

returns_df = pd.DataFrame({
    'Date': returns.index,
    'Return': returns.values
})

# Create price plot
price_plot = (ggplot(price_df, aes(x='Date', y='Price')) +
              geom_line(color='#3366CC') +
              labs(title='S&P 500 Price',
                   x='Date',
                   y='Price') +
              theme_minimal() +
              theme(plot_title=element_text(size=14, face='bold'),
                    axis_title=element_text(size=12),
                    axis_text=element_text(size=10)))

# Create returns plot
returns_plot = (ggplot(returns_df, aes(x='Date', y='Return')) +
                geom_line(color='#FF9900') +
                labs(title='Log Returns',
                     x='Date',
                     y='Log Return') +
                theme_minimal() +
                theme(plot_title=element_text(size=14, face='bold'),
                      axis_title=element_text(size=12),
                      axis_text=element_text(size=10)))

# Display plots
print(price_plot)
print(returns_plot)
```

# GARCH Model Estimation

## Fitting the GARCH(1,1) Model

Now we'll fit a GARCH(1,1) model to the returns data using our implementation:

```{python}
#| label: fit-garch
# Fit GARCH(1,1) model using our implementation
logger.info("Fitting GARCH(1,1) model...")
results = fit_garch(returns)

# Display model summary
logger.info("\nModel Summary:")
logger.info(results.summary())
```

## Model Parameters

The GARCH(1,1) model is specified as:

$$\sigma_t^2 = \omega + \alpha_1 \varepsilon_{t-1}^2 + \beta_1 \sigma_{t-1}^2$$

where:
- $\sigma_t^2$ is the conditional variance
- $\omega$ is the constant term
- $\alpha_1$ is the ARCH effect
- $\beta_1$ is the GARCH effect
- $\varepsilon_{t-1}^2$ is the squared lagged returns
- $\sigma_{t-1}^2$ is the lagged conditional variance

Let's extract and display the model parameters:

```{python}
#| label: model-parameters
# Extract parameters
params = results.params
print("Model Parameters:")
for param, value in params.items():
    print(f"{param}: {value:.6f}")
```

# Volatility Analysis

## Conditional Volatility

Let's plot the conditional volatility using our implementation:

```{python}
#| label: plot-volatility
#| fig-cap: Conditional Volatility

# Create volatility plot using our implementation
volatility_plot = plot_volatility(results, returns)
plt.show()
```

## Model Diagnostics

Let's examine the model residuals using plotnine:

```{python}
#| label: model-diagnostics
#| fig-cap: Standardized Residuals and Q-Q Plot

# Get standardized residuals
std_resid = results.resid / np.sqrt(results.conditional_volatility)

# Create dataframe for residuals
resid_df = pd.DataFrame({
    'Date': std_resid.index,
    'Residual': std_resid.values
})

# Create residuals plot
resid_plot = (ggplot(resid_df, aes(x='Date', y='Residual')) +
              geom_line(color='#FF9900') +
              labs(title='Standardized Residuals',
                   x='Date',
                   y='Standardized Residual') +
              theme_minimal() +
              theme(plot_title=element_text(size=14, face='bold'),
                    axis_title=element_text(size=12),
                    axis_text=element_text(size=10)))

# For Q-Q plot, we need to use matplotlib as plotnine doesn't have a direct Q-Q plot
# Create a figure with two subplots
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

# Plot residuals using plotnine
print(resid_plot)

# Q-Q plot using matplotlib
stats.probplot(std_resid, dist="norm", plot=ax2)
ax2.set_title('Q-Q Plot of Standardized Residuals')
plt.tight_layout()
plt.show()
```

# Volatility Forecasting

## Generating Forecasts

Let's generate volatility forecasts:

```{python}
#| label: forecast
# Generate forecasts
logger.info("Generating volatility forecast...")
forecast = results.forecast(horizon=5)
logger.info("\nVolatility Forecast:")
logger.info(forecast.variance.iloc[-1])
```

## Visualizing Forecasts

Let's visualize the forecast using plotnine:

```{python}
#| label: plot-forecast
#| fig-cap: Volatility Forecast

# Create dataframes for historical and forecast data
historical_df = pd.DataFrame({
    'Date': returns.index[-100:],
    'Volatility': np.sqrt(results.conditional_volatility[-100:]),
    'Type': 'Historical'
})

forecast_dates = pd.date_range(returns.index[-1], periods=6)[1:]
forecast_df = pd.DataFrame({
    'Date': forecast_dates,
    'Volatility': np.sqrt(forecast.variance.iloc[-1]),
    'Type': 'Forecast'
})

# Combine dataframes
combined_df = pd.concat([historical_df, forecast_df])

# Create forecast plot
forecast_plot = (ggplot(combined_df, aes(x='Date', y='Volatility', color='Type')) +
                 geom_line() +
                 labs(title='Volatility Forecast',
                      x='Date',
                      y='Volatility') +
                 scale_color_manual(values=['#3366CC', '#FF9900']) +
                 theme_minimal() +
                 theme(plot_title=element_text(size=14, face='bold'),
                       axis_title=element_text(size=12),
                       axis_text=element_text(size=10),
                       legend_title=element_blank()))

# Display plot
print(forecast_plot)
```

# Conclusion

This implementation demonstrates the key components of GARCH modeling:

1. Data preparation and log returns calculation
2. GARCH(1,1) model estimation
3. Volatility analysis and visualization
4. Model diagnostics
5. Volatility forecasting

The GARCH model provides a powerful framework for modeling and forecasting financial volatility, which is essential for risk management and asset pricing. 
